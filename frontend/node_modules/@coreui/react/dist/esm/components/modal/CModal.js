import { __rest } from '../../node_modules/tslib/tslib.es6.js';
import React, { forwardRef, useRef, useState, useEffect, useLayoutEffect } from 'react';
import PropTypes from 'prop-types';
import classNames from '../../_virtual/index.js';
import { CBackdrop } from '../backdrop/CBackdrop.js';
import { CConditionalPortal } from '../conditional-portal/CConditionalPortal.js';
import { CFocusTrap } from '../focus-trap/CFocusTrap.js';
import { CModalContent } from './CModalContent.js';
import { CModalContext } from './CModalContext.js';
import { CModalDialog } from './CModalDialog.js';
import { useForkedRef } from '../../hooks/useForkedRef.js';
import '@popperjs/core';
import Transition from '../../node_modules/react-transition-group/esm/Transition.js';

const CModal = forwardRef((_a, ref) => {
    var { children, alignment, backdrop = true, className, container, duration = 150, focus = true, fullscreen, keyboard = true, onClose, onClosePrevented, onShow, portal = true, scrollable, size, transition = true, unmountOnClose = true, visible } = _a, rest = __rest(_a, ["children", "alignment", "backdrop", "className", "container", "duration", "focus", "fullscreen", "keyboard", "onClose", "onClosePrevented", "onShow", "portal", "scrollable", "size", "transition", "unmountOnClose", "visible"]);
    const modalRef = useRef(null);
    const modalContentRef = useRef(null);
    const forkedRef = useForkedRef(ref, modalRef);
    const [_visible, setVisible] = useState(visible);
    const [staticBackdrop, setStaticBackdrop] = useState(false);
    const contextValues = {
        visible: _visible,
        setVisible,
    };
    useEffect(() => {
        setVisible(visible);
    }, [visible]);
    useEffect(() => {
        if (_visible) {
            document.addEventListener('mouseup', handleClickOutside);
            document.addEventListener('keydown', handleKeyDown);
        }
        return () => {
            document.removeEventListener('mouseup', handleClickOutside);
            document.removeEventListener('keydown', handleKeyDown);
        };
    }, [_visible]);
    const handleDismiss = () => {
        if (backdrop === 'static') {
            return setStaticBackdrop(true);
        }
        setVisible(false);
    };
    useLayoutEffect(() => {
        onClosePrevented === null || onClosePrevented === void 0 ? void 0 : onClosePrevented();
        setTimeout(() => setStaticBackdrop(false), duration);
    }, [staticBackdrop]);
    // Set focus to modal after open
    useLayoutEffect(() => {
        if (_visible) {
            document.body.classList.add('modal-open');
            if (backdrop) {
                document.body.style.overflow = 'hidden';
                document.body.style.paddingRight = '0px';
            }
        }
        else {
            document.body.classList.remove('modal-open');
            if (backdrop) {
                document.body.style.removeProperty('overflow');
                document.body.style.removeProperty('padding-right');
            }
        }
        return () => {
            document.body.classList.remove('modal-open');
            if (backdrop) {
                document.body.style.removeProperty('overflow');
                document.body.style.removeProperty('padding-right');
            }
        };
    }, [_visible]);
    const handleClickOutside = (event) => {
        if (modalRef.current && modalRef.current == event.target) {
            handleDismiss();
        }
    };
    const handleKeyDown = (event) => {
        if (event.key === 'Escape' && keyboard) {
            handleDismiss();
        }
    };
    return (React.createElement(React.Fragment, null,
        React.createElement(Transition, { in: _visible, mountOnEnter: true, nodeRef: modalRef, onEnter: onShow, onExit: onClose, unmountOnExit: unmountOnClose, timeout: transition ? duration : 0 }, (state) => (React.createElement(CConditionalPortal, { container: container, portal: portal },
            React.createElement(CModalContext.Provider, { value: contextValues },
                React.createElement("div", Object.assign({ className: classNames('modal', {
                        'modal-static': staticBackdrop,
                        fade: transition,
                        show: state === 'entered',
                    }, className), tabIndex: -1 }, (_visible
                    ? { 'aria-modal': true, role: 'dialog' }
                    : { 'aria-hidden': 'true' }), { style: Object.assign({}, (state !== 'exited' && { display: 'block' })) }, rest, { ref: forkedRef }),
                    React.createElement(CModalDialog, { alignment: alignment, fullscreen: fullscreen, scrollable: scrollable, size: size },
                        React.createElement(CFocusTrap, { active: focus && state === 'entered', restoreFocus: true },
                            React.createElement(CModalContent, { ref: modalContentRef }, children)))))))),
        backdrop && (React.createElement(CConditionalPortal, { container: container, portal: portal },
            React.createElement(CBackdrop, { visible: _visible })))));
});
CModal.propTypes = {
    alignment: PropTypes.oneOf(['top', 'center']),
    backdrop: PropTypes.oneOfType([PropTypes.bool, PropTypes.oneOf(['static'])]),
    children: PropTypes.node,
    className: PropTypes.string,
    container: PropTypes.any, // HTMLElement
    duration: PropTypes.number,
    focus: PropTypes.bool,
    fullscreen: PropTypes.oneOfType([
        PropTypes.bool,
        PropTypes.oneOf(['sm', 'md', 'lg', 'xl', 'xxl']),
    ]),
    keyboard: PropTypes.bool,
    onClose: PropTypes.func,
    onClosePrevented: PropTypes.func,
    onShow: PropTypes.func,
    portal: PropTypes.bool,
    scrollable: PropTypes.bool,
    size: PropTypes.oneOf(['sm', 'lg', 'xl']),
    transition: PropTypes.bool,
    unmountOnClose: PropTypes.bool,
    visible: PropTypes.bool,
};
CModal.displayName = 'CModal';

export { CModal };
//# sourceMappingURL=CModal.js.map
