import { __rest } from '../../node_modules/tslib/tslib.es6.js';
import React, { forwardRef, useRef, useState, useCallback, useMemo, useEffect } from 'react';
import PropTypes from 'prop-types';
import classNames from '../../_virtual/index.js';
import { CDropdownContext } from './CDropdownContext.js';
import { useForkedRef } from '../../hooks/useForkedRef.js';
import { usePopper } from '../../hooks/usePopper.js';
import { placementPropType } from '../../props.js';
import getNextActiveElement from '../../utils/getNextActiveElement.js';
import isRTL from '../../utils/isRTL.js';
import { getPlacement } from './utils.js';

const CDropdown = forwardRef((_a, ref) => {
    var { children, alignment, as = 'div', autoClose = true, className, container, dark, direction, offset = [0, 2], onHide, onShow, placement = 'bottom-start', popper = true, popperConfig, portal = false, variant = 'btn-group', visible = false } = _a, rest = __rest(_a, ["children", "alignment", "as", "autoClose", "className", "container", "dark", "direction", "offset", "onHide", "onShow", "placement", "popper", "popperConfig", "portal", "variant", "visible"]);
    const dropdownRef = useRef(null);
    const dropdownMenuRef = useRef(null);
    const forkedRef = useForkedRef(ref, dropdownRef);
    const [dropdownToggleElement, setDropdownToggleElement] = useState(null);
    const [pendingKeyDownEvent, setPendingKeyDownEvent] = useState(null);
    const [_visible, setVisible] = useState(visible);
    const { initPopper, destroyPopper } = usePopper();
    const dropdownToggleRef = useCallback((node) => {
        if (node) {
            setDropdownToggleElement(node);
        }
    }, []);
    const allowPopperUse = popper && typeof alignment !== 'object';
    const Component = variant === 'nav-item' ? 'li' : as;
    const computedPopperConfig = useMemo(() => {
        const defaultPopperConfig = {
            modifiers: [
                {
                    name: 'offset',
                    options: {
                        offset,
                    },
                },
            ],
            placement: getPlacement(placement, direction, alignment, isRTL(dropdownMenuRef.current)),
        };
        return Object.assign(Object.assign({}, defaultPopperConfig), (typeof popperConfig === 'function' ? popperConfig(defaultPopperConfig) : popperConfig));
    }, [offset, placement, direction, alignment, popperConfig]);
    useEffect(() => {
        if (visible) {
            handleShow();
        }
        else {
            handleHide();
        }
    }, [visible]);
    useEffect(() => {
        const toggleElement = dropdownToggleElement;
        const menuElement = dropdownMenuRef.current;
        if (allowPopperUse && menuElement && toggleElement && _visible) {
            initPopper(toggleElement, menuElement, computedPopperConfig);
        }
    }, [dropdownToggleElement]);
    useEffect(() => {
        if (pendingKeyDownEvent !== null) {
            handleKeydown(pendingKeyDownEvent);
            setPendingKeyDownEvent(null);
        }
    }, [pendingKeyDownEvent]);
    const handleHide = useCallback(() => {
        setVisible(false);
        const toggleElement = dropdownToggleElement;
        const menuElement = dropdownMenuRef.current;
        if (allowPopperUse) {
            destroyPopper();
        }
        toggleElement === null || toggleElement === void 0 ? void 0 : toggleElement.removeEventListener('keydown', handleKeydown);
        menuElement === null || menuElement === void 0 ? void 0 : menuElement.removeEventListener('keydown', handleKeydown);
        window.removeEventListener('mouseup', handleMouseUp);
        window.removeEventListener('keyup', handleKeyup);
        onHide === null || onHide === void 0 ? void 0 : onHide();
    }, [dropdownToggleElement, allowPopperUse, destroyPopper, onHide]);
    const handleKeydown = useCallback((event) => {
        if (dropdownMenuRef.current && (event.key === 'ArrowDown' || event.key === 'ArrowUp')) {
            event.preventDefault();
            const target = event.target;
            const items = [
                ...dropdownMenuRef.current.querySelectorAll('.dropdown-item:not(.disabled):not(:disabled)'),
            ];
            getNextActiveElement(items, target, event.key === 'ArrowDown', true).focus();
        }
    }, []);
    const handleKeyup = useCallback((event) => {
        if (autoClose === false) {
            return;
        }
        if (event.key === 'Escape') {
            handleHide();
            dropdownToggleElement === null || dropdownToggleElement === void 0 ? void 0 : dropdownToggleElement.focus();
        }
    }, [autoClose, handleHide]);
    const handleMouseUp = useCallback((event) => {
        if (!dropdownToggleElement || !dropdownMenuRef.current) {
            return;
        }
        if (dropdownToggleElement.contains(event.target)) {
            return;
        }
        if (autoClose === true ||
            (autoClose === 'inside' &&
                dropdownMenuRef.current.contains(event.target)) ||
            (autoClose === 'outside' &&
                !dropdownMenuRef.current.contains(event.target))) {
            setTimeout(() => handleHide(), 1);
            return;
        }
    }, [autoClose, dropdownToggleElement, handleHide]);
    const handleShow = useCallback((event) => {
        const toggleElement = dropdownToggleElement;
        const menuElement = dropdownMenuRef.current;
        if (toggleElement && menuElement) {
            setVisible(true);
            if (allowPopperUse) {
                initPopper(toggleElement, menuElement, computedPopperConfig);
            }
            toggleElement.focus();
            toggleElement.addEventListener('keydown', handleKeydown);
            menuElement.addEventListener('keydown', handleKeydown);
            window.addEventListener('mouseup', handleMouseUp);
            window.addEventListener('keyup', handleKeyup);
            if (event && (event.key === 'ArrowDown' || event.key === 'ArrowUp')) {
                setPendingKeyDownEvent(event);
            }
            onShow === null || onShow === void 0 ? void 0 : onShow();
        }
    }, [
        dropdownToggleElement,
        allowPopperUse,
        initPopper,
        computedPopperConfig,
        handleKeydown,
        handleMouseUp,
        handleKeyup,
        onShow,
    ]);
    const contextValues = {
        alignment,
        container,
        dark,
        dropdownMenuRef,
        dropdownToggleRef,
        handleHide,
        handleShow,
        popper: allowPopperUse,
        portal,
        variant,
        visible: _visible,
    };
    return (React.createElement(CDropdownContext.Provider, { value: contextValues }, variant === 'input-group' ? (React.createElement(React.Fragment, null, children)) : (React.createElement(Component, Object.assign({ className: classNames(variant === 'nav-item' ? 'nav-item dropdown' : variant, {
            'dropdown-center': direction === 'center',
            'dropup dropup-center': direction === 'dropup-center',
            [`${direction}`]: direction && direction !== 'center' && direction !== 'dropup-center',
        }, className) }, rest, { ref: forkedRef }), children))));
});
const alignmentDirection = PropTypes.oneOf(['start', 'end']);
CDropdown.propTypes = {
    alignment: PropTypes.oneOfType([
        alignmentDirection,
        PropTypes.shape({ xs: alignmentDirection.isRequired }),
        PropTypes.shape({ sm: alignmentDirection.isRequired }),
        PropTypes.shape({ md: alignmentDirection.isRequired }),
        PropTypes.shape({ lg: alignmentDirection.isRequired }),
        PropTypes.shape({ xl: alignmentDirection.isRequired }),
        PropTypes.shape({ xxl: alignmentDirection.isRequired }),
    ]),
    as: PropTypes.elementType,
    autoClose: PropTypes.oneOfType([
        PropTypes.bool,
        PropTypes.oneOf(['inside', 'outside']),
    ]),
    children: PropTypes.node,
    className: PropTypes.string,
    dark: PropTypes.bool,
    direction: PropTypes.oneOf(['center', 'dropup', 'dropup-center', 'dropend', 'dropstart']),
    offset: PropTypes.any, // TODO: find good proptype
    onHide: PropTypes.func,
    onShow: PropTypes.func,
    placement: placementPropType,
    popper: PropTypes.bool,
    popperConfig: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),
    portal: PropTypes.bool,
    variant: PropTypes.oneOf(['btn-group', 'dropdown', 'input-group', 'nav-item']),
    visible: PropTypes.bool,
};
CDropdown.displayName = 'CDropdown';

export { CDropdown };
//# sourceMappingURL=CDropdown.js.map
